<h1>Chapter 4</h1><h1>Git на сервере</h1>

<p>К этому моменту вы уже должны уметь решать большинство повседневных задач, для которых будете использовать Git. Однако, для совместной работы в Git'е, вам необходим удалённый репозиторий. Несмотря на то, что технически вы можете отправлять и забирать изменения непосредственно из личных репозиториев, делать это не рекомендуется. Вы легко можете испортить то, над чем работают другие, если не будете аккуратны. К тому же, вам бы наверняка хотелось, чтобы остальные имели доступ к репозиторию даже если ваш компьютер выключен, поэтому наличие более надежного репозитория обычно весьма полезно. Поэтому предпочтительный метод взаимодействия с кем-либо — это создание промежуточного репозитория, к которому вы оба будете иметь доступ, и отправка и получение изменений через него. Мы будем называть этот репозиторий "Git-сервер", но обычно размещение Git-репозитория требует очень небольшого количества ресурсов, поэтому вряд ли вам для этого будет нужен весь сервер.</p>

<p>Запустить Git-сервер просто. Для начала вам следует выбрать протокол, который вы будете использовать для связи с сервером. Первая часть этой главы описывает доступные протоколы и их достоинства и недостатки. Следующие части освещают базовые конфигурации с использованием этих протоколов, а также настройку вашего сервера для работы с ними. Наконец, мы рассмотрим несколько вариантов готового хостинга, если вы не против разместить ваш код на чьём-то сервере и вы не хотите мучиться с настройками и поддержкой вашего собственного сервера.</p>

<p>Если вас не интересует настройка собственного сервера, вы можете перейти сразу к последней части этой главы для настройки аккаунта на Git-хостинге, и затем перейти к следующей главе, где мы обсудим различные аспекты работы с распределённой системой контроля версий.</p>

<p>Удалённый репозиторий — это обычно <em>голый (чистый, bare) репозиторий</em> — Git-репозиторий, не имеющий рабочего каталога. Поскольку этот репозиторий используется только для обмена, нет причин создавать рабочую копию на диске, и он содержит только данные Git'а. Проще говоря, голый репозиторий содержит только каталог <code>.git</code> вашего проекта и ничего больше.</p>



<div class="book edition1">
	<h1>3.3 Ветвление в Git - Управление ветками</h1>
	<div><h2>Управление ветками</h2>

  <center><img class="lazy-load" src="img/s.gif" data-src="img/sm0004-WorldKitchin1777.jpg"  alt="TEST"></center>

	<p>Теперь, когда вы уже попробовали создавать, объединять и удалять ветки, пора познакомиться с некоторыми инструментами для управления ветками, которые вам пригодятся, когда вы начнёте использовать ветки постоянно.</p>

	<p>Команда <code>git branch</code> делает несколько больше, чем просто создаёт и удаляет ветки. Если вы выполните её без аргументов, то получите простой список имеющихся у вас веток:</p>

	<pre><code>$ git branch
	  iss53
	* master
	  testing
	</code></pre>

	

	<p>Обратите внимание на символ <code>*</code>, стоящий перед веткой <code>master</code>: он указывает на ветку, на которой вы находитесь в настоящий момент. Это означает, что если вы сейчас выполните коммит, ветка <code>master</code> переместится вперёд в соответствии с вашими последними изменениями. Чтобы посмотреть последний коммит на каждой из веток, выполните команду <code>git branch -v</code>:</p>

	<pre><code>$ git branch -v
	  iss53   93b412c fix javascript issue
	* master  7a98805 Merge branch 'iss53'
	  testing 782fd34 add scott to the author list in the readmes
	</code></pre>

	<p>Ещё одна полезная возможность для выяснения состояния веток состоит в том, чтобы оставить в этом списке только те ветки, которые вы слили (или не слили) в ветку, на которой сейчас находитесь. Для этих целей в Git'е есть опции <code>--merged</code> и <code>--no-merged</code>. Чтобы посмотреть те ветки, которые вы уже слили с текущей, можете выполнить команду <code>git branch --merged</code>:</p>

	<pre><code>$ git branch --merged
	  iss53
	* master
	</code></pre>

	

	<p>Из-за того что мы ранее слили <code>iss53</code>, мы видим её в этом списке. Те ветки из этого списка, перед которыми нет символа <code>*</code>, можно смело удалять командой <code>git branch -d</code>; вы уже включили наработки из этих веток в другую ветку, так что вы ничего не потеряете.</p>

	<p>Чтобы увидеть все ветки, содержащие наработки, которые вы пока ещё не слили в текущую ветку, выполните команду <code>git branch --no-merged</code>:</p>

	<pre><code>$ git branch --no-merged
	  testing
	</code></pre>

	<p>Вы увидите оставшуюся ветку. Так как она содержит ещё не слитые наработки, попытка удалить её командой <code>git branch -d</code> не увенчается успехом:</p>

	<pre><code>$ git branch -d testing
	error: The branch 'testing' is not an ancestor of your current HEAD.
	If you are sure you want to delete it, run 'git branch -D testing'.
	</code></pre>

	<p>Если вы действительно хотите удалить ветку и потерять наработки, вы можете сделать это при помощи опции <code>-D</code>, как указано в подсказке.</p>

	<center><img class="lazy-load" src="img/s.gif" data-src="img/sm0258-tallis-Polynesia-l.jpg" alt="TEST"></center>

	</div>
	</div>


<div class="book edition1">
	<h1>3.4 Ветвление в Git - Приёмы работы с ветками</h1>
	<div><h2>Приёмы работы с ветками</h2>

	<p>Теперь, когда вы познакомились с основами ветвления и слияния, что вам делать с ветками дальше? В этом разделе мы рассмотрим некоторые стандартные приёмы работы, которые становятся возможными благодаря лёгкости осуществления ветвления. И вы сможете выбрать, включить ли вам какие-то из них в свой цикл разработки.</p>



	<h3 id="Долгоживущие-ветки"><a href="#Долгоживущие-ветки">Долгоживущие ветки</a></h3>

	

	<p>Так как Git использует простое трёхходовое слияние, периодически сливать одну ветку с другой на протяжении большого промежутка времени достаточно просто. Это значит, вы можете иметь несколько веток, которые всегда открыты и которые вы используете для разных стадий вашего цикла разработки; вы можете регулярно сливать их одну в другую.</p>

	<p>Многие разработчики Git'а придерживаются такого подхода, при котором ветка <code>master</code> содержит исключительно стабильный код — единственный выпускаемый код. Для разработки и тестирования используется параллельная ветка, называемая <code>develop</code> или <code>next</code>, она может не быть стабильной постоянно, но в стабильные моменты её можно слить в <code>master</code>. Эта ветка используется для объединения завершённых задач из тематических веток (временных веток наподобие <code>iss53</code>), чтобы удостовериться, что эти изменения проходят все тесты и не вызывают ошибок.</p>

	<p>В действительности же, мы говорим об указателях, передвигающихся вверх по линии коммитов, которые вы делаете. Стабильные ветки далеко внизу линии вашей истории коммитов, наиболее свежие ветки находятся ближе к верхушке этой линии (см. рис. 3-18).</p>

	<p></p><center><img class="lazy-load" src="img/s.gif" data-src="img/sm0136-solar-system(f9586)-l.jpg" alt="TEST"></center><br> 
	Рисунок 3-18. Более стабильные ветки, как правило, находятся дальше в истории коммитов.<p></p>

	<p>В общем, об этом проще думать как о силосных башнях, где набор коммитов переходит в более стабильную башню только тогда, когда он полностью протестирован (см. рис. 3-19).</p>

	<p></p><center><img class="lazy-load" src="img/s.gif" data-src="img/sm0068-Australia-s.jpg" alt="TEST"></center><br> 
	Рисунок 3-19. Может быть полезным думать о ветках как о силосных башнях.<p></p>

	<p>Вы можете применять эту идею для нескольких разных уровней стабильности. Некоторые большие проекты также имеют ветку <code>proposed</code> или <code>pu</code> (proposed updates — предлагаемые изменения), которые включают в себя ветки, не готовые для перехода в ветку <code>next</code> или <code>master</code>. Идея такова, что ваши ветки находятся на разных уровнях стабильности; когда они достигают более высокого уровня стабильности, они сливаются с веткой, стоящей на более высоком уровне.
	Опять-таки, иметь долгоживущие ветки не обязательно, но зачастую это полезно, особенно когда вы имеете дело с очень большими и сложными проектами.</p>

	<h3 id="Тематические-ветки"><a href="#Тематические-ветки">Тематические ветки</a></h3>

	<p>Тематические ветки, однако, полезны в проектах любого размера. Тематическая ветка — недолговечная ветка, которую вы создаёте и используете для работы над некоторой отдельной функциональностью или для вспомогательной работы. Это то, чего вы, вероятно, никогда не делали с системами контроля версий раньше, так как создание и слияние веток обычно слишком затратно. Но в Git'е принято создавать ветки, работать над ними, сливать и удалять их по несколько раз в день.</p>

	<p>Мы видели подобное в последнем разделе, где вы создавали ветки <code>iss53</code> и <code>hotfix</code>. Вы сделали всего несколько коммитов на этих ветках и удалили их сразу же после слияния с основной веткой. Такая техника позволяет быстро и полноценно переключать контекст. Ибо когда все изменения разбиты по веткам и определённым темам, намного проще понять, что было сделано, во время проверки и просмотра кода. Вы можете сохранить там изменения на несколько минут, дней или месяцев, а затем, когда они готовы, слить их в основную ветку, независимо от порядка, в котором их создавали или работали над ними.</p>

	<p>Рассмотрим пример, когда при выполнении некоторой работы в ветке <code>master</code>, делается новая ветка для решения некой проблемы (<code>iss91</code>), выполняется немного работы на ней, от неё ответвляется ещё одна ветка для другого пути решения той же задачи (<code>iss91v2</code>), потом осуществляется переход назад на основную ветку (<code>master</code>), и некоторое время работа ведётся на ней, затем делается ответвление от неё для выполнения чего-то, в чём вы не уверены, что это хорошая идея (ветка <code>dumbidea</code>). Ваша история коммитов будет выглядеть примерно так как на рисунке 3-20.</p>


	Рисунок 3-20. История коммитов с несколькими тематическими ветками.<p></p>

	<p>Теперь представим, вы решили, что вам больше нравится второе решение для вашей задачи (<code>iss91v2</code>); и вы показываете ветку <code>dumbidea</code> вашим коллегам и оказывается, что она просто гениальна. Так что вы можете выбросить оригинальную ветку <code>iss91</code> (теряя при этом коммиты C5 и C6) и слить две другие. Тогда ваша история будет выглядеть как на рисунке 3-21.</p>


	Рисунок 3-21. Ваша история после слияния dumbidea и iss91v2.<p></p>

	<p>Важно запомнить, что когда вы выполняете все эти действия, ветки являются полностью локальными. Когда вы выполняете ветвление и слияние, всё происходит только в вашем репозитории — связь с сервером не осуществляется.</p>

</div>
</div>


<div class="book edition1">
	<h1>3.5 Ветвление в Git - Удалённые ветки</h1>
	<div><h2>Удалённые ветки</h2>

	<p>Удалённые ветки — это ссылки на состояние веток в ваших удалённых репозиториях. Это локальные ветки, которые нельзя перемещать; они двигаются автоматически всякий раз, когда вы осуществляете связь по сети. Удалённые ветки действуют как закладки для напоминания о том, где ветки в удалённых репозиториях находились во время последнего подключения к ним.</p>

	<p>Они выглядят как <code>(имя удал. репоз.)/(ветка)</code>. Например, если вы хотите посмотреть, как выглядела ветка <code>master</code> на сервере <code>origin</code> во время последнего соединения с ним, проверьте ветку <code>origin/master</code>. Если вы с партнёром работали над одной проблемой, и он выложил ветку <code>iss53</code>, у вас может быть своя локальная ветка <code>iss53</code>; но та ветка на сервере будет указывать на коммит в <code>origin/iss53</code>.</p>

	<p>Всё это, возможно, сбивает с толку, поэтому давайте рассмотрим пример. Скажем, у вас в сети есть свой Git-сервер на <code>git.ourcompany.com</code>. Если вы с него что-то склонируете (clone), Git автоматически назовёт его <code>origin</code>, заберёт оттуда все данные, создаст указатель на то, на что там указывает ветка <code>master</code>, и назовёт его локально <code>origin/master</code> (но вы не можете его двигать). Git также сделает вам вашу собственную ветку <code>master</code>, которая будет начинаться там же, где и ветка <code>master</code> в origin, так что вам будет с чем работать (см. рис. 3-22).</p>


	Рисунок 3-23. При выполнении локальной работы и отправке кем-то изменений на удалённый сервер каждая история продолжается по-разному.<p></p>

	<p>Для синхронизации вашей работы выполняется команда <code>git fetch origin</code>. Эта команда ищет, какому серверу соответствует origin (в нашем случае это <code>git.ourcompany.com</code>); извлекает оттуда все данные, которых у вас ещё нет, и обновляет ваше локальное хранилище данных; сдвигает указатель <code>origin/master</code> на новую позицию (см. рис. 3-24).</p>



	<p>Чтобы продемонстрировать то, как будут выглядеть удалённые ветки в ситуации с несколькими удалёнными серверами, предположим, что у вас есть ещё один внутренний Git-сервер, который используется для разработки только одной из ваших команд разработчиков. Этот сервер находится на <code>git.team1.ourcompany.com</code>. Вы можете добавить его в качестве новой удалённой ссылки на проект, над которым вы сейчас работаете с помощью команды <code>git remote add</code> так же, как было описано в главе 2. Дайте этому удалённому серверу имя <code>teamone</code>, которое будет сокращением для полного URL (см. рис. 3-25).</p>

	


	<p>Теперь можете выполнить <code>git fetch teamone</code>, чтобы извлечь всё, что есть на сервере и нет у вас. Так как в данный момент на этом сервере есть только часть данных, которые есть на сервере <code>origin</code>, Git не получает никаких данных, но выставляет удалённую ветку с именем <code>teamone/master</code>, которая указывает на тот же коммит, что и ветка <code>master</code> на сервере <code>teamone</code> (см. рис. 3-26).</p>




	<h3 id="Отправка-изменений"><a href="#Отправка-изменений">Отправка изменений</a></h3>

	<p>Когда вы хотите поделиться веткой с окружающими, вам необходимо отправить (push) её на удалённый сервер, на котором у вас есть права на запись. Ваши локальные ветки автоматически не синхронизируются с удалёнными серверами — вам нужно явно отправить те ветки, которыми вы хотите поделиться. Таким образом, вы можете использовать свои личные ветки для работы, которую вы не хотите показывать, и отправлять только те тематические ветки, над которыми вы хотите работать с кем-то совместно.</p>

	<p>Если у вас есть ветка <code>serverfix</code>, над которой вы хотите работать с кем-то ещё, вы можете отправить её точно так же, как вы отправляли вашу первую ветку. Выполните <code>git push (удал. сервер) (ветка)</code>:</p>

	<pre><code>$ git push origin serverfix
	Counting objects: 20, done.
	Compressing objects: 100% (14/14), done.
	Writing objects: 100% (15/15), 1.74 KiB, done.
	Total 15 (delta 5), reused 0 (delta 0)
	To git@github.com:schacon/simplegit.git
	 * [new branch]      serverfix -&gt; serverfix
	</code></pre>

	<p>Это в некотором роде сокращение. Git автоматически разворачивает имя ветки <code>serverfix</code> до <code>refs/heads/serverfix:refs/heads/serverfix</code>, что означает “возьми мою локальную ветку serverfix и обнови из неё удалённую ветку serverfix”. Мы подробно обсудим часть с <code>refs/heads/</code> в главе 9, но обычно её можно опустить. Вы также можете выполнить <code>git push origin serverfix:serverfix</code> — произойдёт то же самое — здесь говорится “возьми мой serverfix и сделай его удалённым serverfix”. Можно использовать этот формат для отправки локальной ветки в удалённую ветку с другим именем. Если вы не хотите, чтобы ветка называлась <code>serverfix</code> на удалённом сервере, то вместо предыдущей команды выполните <code>git push origin serverfix:awesomebranch</code>. Так ваша локальная ветка <code>serverfix</code> отправится в ветку <code>awesomebranch</code> удалённого проекта.</p>

	<p>В следующий раз, когда один из ваших соавторов будет получать обновления с сервера, он получит ссылку на то, на что указывает <code>serverfix</code> на сервере, как удалённую ветку <code>origin/serverfix</code>:</p>

	<pre><code>$ git fetch origin
	remote: Counting objects: 20, done.
	remote: Compressing objects: 100% (14/14), done.
	remote: Total 15 (delta 5), reused 0 (delta 0)
	Unpacking objects: 100% (15/15), done.
	From git@github.com:schacon/simplegit
	 * [new branch]      serverfix    -&gt; origin/serverfix
	</code></pre>

	<p>Важно отметить, что когда при получении данных у вас появляются новые удалённые ветки, вы не получаете автоматически для них локальных редактируемых копий. Другими словами, в нашем случае вы не получите новую ветку <code>serverfix</code> — только указатель <code>origin/serverfix</code>, который вы не можете менять.</p>

	<p>Чтобы слить эти наработки в свою текущую рабочую ветку, выполните <code>git merge origin/serverfix</code>. Если вам нужна своя собственная ветка <code>serverfix</code>, над которой вы сможете работать, то вы можете создать её на основе удалённой ветки:</p>

	<pre><code>$ git checkout -b serverfix origin/serverfix
	Branch serverfix set up to track remote branch refs/remotes/origin/serverfix.
	Switched to a new branch "serverfix"
	</code></pre>

	<p>Это даст вам локальную ветку, на которой можно работать. Она будет начинаться там, где и <code>origin/serverfix</code>.</p>

	<h3 id="Отслеживание-веток"><a href="#Отслеживание-веток">Отслеживание веток</a></h3>

	<p>Получение локальной ветки с помощью <code>git checkout</code> из удалённой ветки автоматически создаёт то, что называется <em>отслеживаемой веткой</em>. Отслеживаемые ветки — это локальные ветки, которые напрямую связаны с удалённой веткой. Если, находясь на отслеживаемой ветке, вы наберёте <code>git push</code>, Git уже будет знать, на какой сервер и в какую ветку отправлять изменения. Аналогично выполнение <code>git pull</code> на одной из таких веток сначала получает все удалённые ссылки, а затем автоматически делает слияние с соответствующей удалённой веткой.</p>

	<p>При клонировании репозитория, как правило, автоматически создаётся ветка <code>master</code>, которая отслеживает <code>origin/master</code>, поэтому <code>git push</code> и <code>git pull</code> работают для этой ветки "из коробки" и не требуют дополнительных аргументов. Однако, вы можете настроить отслеживание и других веток удалённого репозитория. Простой пример, как это сделать, вы увидели только что — <code>git checkout -b [ветка] [удал. сервер]/[ветка]</code>. Если вы используете Git версии 1.6.2 или более позднюю, можете также воспользоваться сокращением <code>--track</code>:</p>

	<pre><code>$ git checkout --track origin/serverfix
	Branch serverfix set up to track remote branch refs/remotes/origin/serverfix.
	Switched to a new branch "serverfix"
	</code></pre>
	<center><img class="lazy-load" src="img/s.gif" data-src="img/sm0092-British-Empire.jpg" alt="TEST"></center>
	<p>Чтобы настроить локальную ветку с именем, отличным от имени удалённой ветки, вы можете легко использовать первую версию с другим именем локальной ветки:</p>

	<pre><code>$ git checkout -b sf origin/serverfix
	Branch sf set up to track remote branch refs/remotes/origin/serverfix.
	Switched to a new branch "sf"
	</code></pre>

	<p>Теперь ваша локальная ветка sf будет автоматически отправлять (push) и получать (pull) изменения из origin/serverfix.</p>


	<p>Скажем, вы и ваши соавторы закончили с нововведением и слили его в ветку <code>master</code> на удалённом сервере (или в какую-то другую ветку, где хранится стабильный код). Вы можете удалить ветку на удалённом сервере, используя несколько бестолковый синтаксис <code>git push [удал. сервер] :[ветка]</code>. Чтобы удалить ветку <code>serverfix</code> на сервере, выполните следующее:</p>

	<pre><code>$ git push origin :serverfix
	To git@github.com:schacon/simplegit.git
	 - [deleted]         serverfix
	</code></pre>

	<p>Хлоп. Нет больше ветки на вашем сервере. Вам может захотеться сделать закладку на текущей странице, так как эта команда вам понадобится, а синтаксис вы, скорее всего, забудете. Можно запомнить эту команду вернувшись к синтаксису <code>git push [удал. сервер] [лок. ветка]:[удал. ветка]</code>, который мы рассматривали немного раньше. Опуская часть <code>[лок. ветка]</code>, вы, по сути, говорите “возьми ничто в моём репозитории и сделай так, чтобы в <code>[удал. ветка]</code> было то же самое”.</p>

</div>
</div>


<div  class="book edition1">
    <h1>4.1 Git на сервере - Протоколы</h1>
  <div><h2>Протоколы</h2>

<p>Git умеет работать с четырьмя сетевыми протоколами для передачи данных: локальный, Secure Shell (SSH), Git и HTTP. В этой части мы обсудим каждый из них и в каких случаях стоит (или не стоит) их использовать.</p>

<p>Важно понимать, что за исключением протокола HTTP, все эти протоколы требуют, чтобы Git был установлен и работал на сервере.</p>

<h3 id="Локальный-протокол"><a href="#Локальный-протокол">Локальный протокол</a></h3>

<p>Базовым протоколом является <em>Локальный протокол</em>, при использовании которого удалённый репозиторий — другой каталог на диске. Наиболее часто он используется, если все члены команды имеют доступ к общей файловой системе, например к NFS, или, что менее вероятно, когда все работают на одном компьютере. Последний вариант не столь хорош, поскольку все копии вашего репозитория находятся на одном компьютере, делая возможность потерять всё более вероятной.</p>

<p>Если у вас смонтирована общая файловая система, вы можете клонировать, отправлять и получать изменения из локального репозитория. Чтобы склонировать такой репозиторий или добавить его в качестве удалённого в существующий проект, используйте путь к репозиторию в качестве URL. Например, для клонирования локального репозитория вы можете выполнить что-то вроде этого:</p>

<pre><code>$ git clone /opt/git/project.git
</code></pre>

<p>Или этого:</p>

<pre><code>$ git clone file:///opt/git/project.git
</code></pre>

<p>Git работает немного по-другому если вы укажете префикс <code>file://</code> для вашего URL. Когда вы просто указываете путь, Git пытается использовать жёсткие ссылки и копировать файлы, когда это нужно. Если вы указываете <code>file://</code>, Git работает с данными так же как при использовании сетевых протоколов, что в целом менее эффективный способ передачи данных. Причиной для использования <code>file://</code> может быть необходимость создания чистой копии репозитория без лишних внешних ссылок и объектов, обычно после импорта из другой СКВ или чего-то похожего (см. главу 9 о задачах поддержки). Мы будем использовать обычные пути, поскольку это практически всегда быстрее.</p>

<p>Чтобы добавить локальный репозиторий в существующий проект, вы можете воспользоваться командой:</p>

<pre><code>$ git remote add local_proj /opt/git/project.git
</code></pre>

<p>Теперь вы можете отправлять и получать изменения из этого репозитория так, как вы это делали по сети.</p>

<h4>Преимущества</h4>

<p>Преимущества основанных на файлах хранилищ в том, что они просты и используют существующие разграничения прав на файлы и сетевой доступ. Если у вас уже есть общая файловая система, доступ к которой имеет вся команда, настройка репозитория очень проста. Вы помещаете голый репозиторий туда, куда все имеют доступ, и выставляете права на чтение и запись так же, как вы это делали бы для любого другого общего каталога. Мы обсудим, как экспортировать голую копию репозитория для этой цели в следующем разделе, "Настройка Git на сервере".</p>

<p>Также это хорошая возможность быстро получить наработки из чьего-то рабочего репозитория. Если вы и ваш коллега работаете над одним и тем же проектом и он хочет, чтобы вы проверили что-то, то запуск команды вроде <code>git pull /home/john/project</code> зачастую проще, чем если бы он отправил на удалённый сервер, а вы забрали бы оттуда.</p>

<h4>Недостатки</h4>

<p>Недостаток этого метода в том, что общий доступ обычно сложнее настроить и получить из разных мест, чем простой сетевой доступ. Если вы хотите отправлять со своего ноутбука, когда вы дома, вы должны смонтировать удалённый диск, что может быть сложно и медленно по сравнению с сетевым доступом.</p>

<p>Также важно упомянуть, что не всегда использование общей точки монтирования является быстрейшим вариантом. Локальный репозиторий быстрый, только если вы имеете быстрый доступ к данным. Репозиторий на NFS часто медленнее, чем репозиторий через SSH на том же сервере, позволяющий Git'у использовать на полную локальные диски на каждой системе.</p>
<center><img class="lazy-load" src="img/s.gif" data-src="img/sm0011-WorldGeol(d5906).jpg" alt="TEST"></center>

<h3 id="Протокол-SSH"><a href="#Протокол-SSH">Протокол SSH</a></h3>

<p>Наверное, наиболее часто используемый транспортный протокол — это SSH. Причина этого в том, что доступ по SSH уже есть на многих серверах, а если его нет, то его очень легко настроить. Кроме того, SSH — единственный из сетевых протоколов, предоставляющий доступ и на чтение, и на запись. Два других сетевых протокола (HTTP и Git) в большинстве случаев дают доступ только на чтение, поэтому даже если они вам доступны, вам всё равно понадобится SSH для записи. К тому же SSH протокол с аутентификацией, и благодаря его распространённости обычно его легко настроить и использовать.</p>

<p>Чтобы склонировать Git-репозиторий по SSH, вы можете указать префикс ssh:// в URL, например:</p>

<pre><code>$ git clone ssh://user@server/project.git
</code></pre>

<p>Альтернативно для протокола SSH можно использовать более короткую запись в scp-стиле:</p>

<pre><code>$ git clone user@server:project.git
</code></pre>

<p>Также вы можете не указывать имя пользователя, Git будет использовать то, под которым вы вошли в систему.</p>

<h4>Достоинства</h4>

<p>SSH имеет множество достоинств. Во-первых, вы, по сути, вынуждены его использовать, когда нужен авторизованный доступ на запись к репозиторию через сеть. Во-вторых, SSH достаточно легко настроить — SSH-демоны распространены, многие системные администраторы имеют опыт работы с ними, и во многих дистрибутивах они уже настроены или есть утилиты для управления ими. Также доступ по SSH безопасен — данные передаются зашифрованными по авторизованным каналам. Наконец, так же как и Git-протокол и локальный протокол, SSH эффективен, делая данные перед передачей максимально компактными.</p>

<h4>Недостатки</h4>

<p>Недостаток SSH в том, что, используя его, вы не можете обеспечить анонимный доступ к репозиторию. Клиенты должны иметь доступ к машине по SSH, даже для работы в режиме только на чтение, что делает SSH неподходящим для проектов с открытым исходным кодом. Если вы используете Git только внутри корпоративной сети, то возможно SSH единственный протокол, с которым вам придётся иметь дело. Если же вам нужен анонимный доступ на чтение для ваших проектов, вам придётся настроить SSH для себя, чтобы выкладывать изменения, и что-нибудь другое для других, для скачивания.</p>

<h3 id="Git-протокол"><a href="#Git-протокол">Git-протокол</a></h3>

<p>Следующий протокол — Git-протокол. Вместе с Git'ом поставляется специальный демон, который слушает порт 9418 и предоставляет сервис, схожий с протоколом ssh, но абсолютно без аутентификации. Чтобы использовать Git-протокол для репозитория, вы должны создать файл <code>git-daemon-export-ok</code>, иначе демон не будет работать с этим репозиторием, но следует помнить, что в протоколе отсутствуют средства безопасности. Соответственно, любой репозиторий в Git'е может быть либо доступен для клонирования всем, либо не доступен никому. Как следствие, обычно вы не можете отправлять изменения по этому протоколу. Вы можете открыть доступ на запись, но из-за отсутствия авторизации в этом случае кто угодно, зная URL вашего проекта, сможет его изменить. В общем, это редко используемая возможность.</p>

<h4>Достоинства</h4>

<p>Git-протокол — самый быстрый из доступных протоколов. Если у вас проект с публичным доступом и большой трафик или у вас очень большой проект, для которого не требуется авторизация пользователей для чтения, вам стоит настроить Git-демон для вашего проекта. Он использует тот же механизм передачи данных, что и протокол SSH, но без дополнительных затрат на кодирование и аутентификацию.</p>

<h4>Недостатки</h4>

<p>Недостатком Git-протокола является отсутствие аутентификации. Поэтому обычно не следует использовать этот протокол как единственный способ доступа к вашему проекту. Обычно он используется в паре с SSH для разработчиков, имеющих доступ на запись, тогда как все остальные используют <code>git://</code> с доступом только на чтение.
Кроме того, это, вероятно, самый сложный для настройки протокол. Вы должны запустить собственно демон, не являющийся стандартным. Мы рассмотрим его настройку в разделе "Gitosis" этой главы. К тому же, ему необходим сервис <code>xinetd</code> или ему подобный, что не всегда легко сделать. Также необходимо, чтобы сетевой экран позволял доступ на порт 9418, который не является стандартным портом, всегда разрешённым в корпоративных брандмауэрах. За сетевыми экранами крупных корпораций этот неизвестный порт обычно заблокирован.</p>

<h3 id="Протокол-HTTP/S"><a href="#Протокол-HTTP/S">Протокол HTTP/S</a></h3>

<p>Последний доступный протокол — HTTP. Прелесть протоколов HTTP и HTTPS в простоте их настройки. По сути, всё, что необходимо сделать — поместить голый репозиторий внутрь каталога с HTTP документами, установить перехватчик <code>post-update</code> и всё (подробнее о перехватчиках будет рассказано в главе 7). Теперь каждый, имеющий доступ к веб-серверу, на котором был размещён репозиторий, может его склонировать. Таким образом, чтобы открыть доступ к своему репозиторию на чтение через HTTP, нужно сделать что-то наподобие этого:</p>

<pre><code>$ cd /var/www/htdocs/
$ git clone --bare /path/to/git_project gitproject.git
$ cd gitproject.git
$ mv hooks/post-update.sample hooks/post-update
$ chmod a+x hooks/post-update
</code></pre>

<p>Вот и всё. Перехватчик <code>post-update</code>, входящий в состав Git'а по умолчанию, выполняет необходимую команду (<code>git update-server-info</code>), чтобы извлечение (fetch) и клонирование (clone) по HTTP работали правильно. Эта команда выполняется, когда вы отправляете изменения в репозиторий по SSH. Затем остальные могут склонировать его командой:</p>

<pre><code>$ git clone http://example.com/gitproject.git
</code></pre>
<center><img class="lazy-load" src="img/s.gif" data-src="img/sm0191-World-map-1808-l.jpg" alt="TEST"></center>

<p>В рассмотренном примере мы использовали каталог <code>/var/www/htdocs</code>, обычно используемый сервером Apache, но вы можете использовать любой веб-сервер, отдающий статические данные, расположив голый репозиторий в нужном каталоге. Данные Git'а представляют собой обычные файлы (в главе 9 предоставление данных рассматривается более подробно).</p>

<p>Также возможна настройка Git'а для доступа на запись через HTTP, однако этот способ мало распространён и требует от вас настройки WebDAV. Поскольку этот способ редко используется, мы не будем рассматривать его в рамках этой книги. Если вас интересует использование протокола HTTP с возможностью записи, вы можете почитать о подготовке репозитория в этой статье: <code>http://www.kernel.org/pub/software/scm/git/docs/howto/setup-git-server-over-http.txt</code>. Положительным моментом настройки Git'а для записи через HTTP является то, что вы можете использовать любой WebDAV-сервер, без поддержки каких-либо специфичных для Git'а возможностей. Таким образом если ваш хостинг предоставляет WebDAV, вы можете обеспечить запись обновлений репозитория на ваш веб-сайт.</p>

<h4>Достоинства</h4>

<p>Положительным аспектом использования протокола HTTP является простота настройки. Запуск всего нескольких команд даёт вам возможность предоставить миру доступ к вашему Git-репозиторию. Вам понадобится всего несколько минут, чтобы сделать это. Кроме того, использование протокола HTTP не потребует много ресурсов вашего сервера. Поскольку в основном используется статический HTTP-сервер, обычный сервер Apache может обрабатывать в среднем тысячи файлов в секунду — трудно перегрузить даже небольшой сервер.</p>

<p>Также вы можете выставлять ваши репозитории в режиме только для чтения через HTTPS, т.е. вы можете шифровать трафик, или вы даже можете авторизовывать клиентов по SSL-сертификату. Обычно для этих целей легче использовать открытые SSH-ключи, но в некоторых конкретных случаях лучшим решением может оказаться использование подписанных SSL-сертификатов или других методов аутентификации, основанных на HTTP, для доступа на чтение через HTTPS.</p>

<p>Другим плюсом является то, что HTTP — настолько широко используемый протокол, что корпоративные сетевые экраны часто настроены на пропускание трафика, проходящего через этот порт.</p>

<h4>Недостатки</h4>

<p>Обратной стороной использования протокола HTTP является его относительно низкая эффективность для клиента. Обычно клонирование или извлечение изменений из репозитория при использовании HTTP гораздо продолжительнее, а объем данных и нагрузка на сеть намного больше, чем у любого другого имеющегося сетевого протокола. Поскольку он не заботится о том, чтобы передавались только необходимые вам данные — никакой динамической обработки на стороне сервера в этом случае не происходит — протокол HTTP часто называют <em>тупым</em> (dumb) протоколом. Более подробно о разнице в эффективности протокола HTTP и других протоколов рассказывается в главе 9.</p>