<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Document</title>
</head>
<body>
<div id="main" class="book edition1">
    <h1>3.3 Ветвление в Git - Управление ветками</h1>
  <div><h2>Управление ветками</h2>

<p>Теперь, когда вы уже попробовали создавать, объединять и удалять ветки, пора познакомиться с некоторыми инструментами для управления ветками, которые вам пригодятся, когда вы начнёте использовать ветки постоянно.</p>

<p>Команда <code>git branch</code> делает несколько больше, чем просто создаёт и удаляет ветки. Если вы выполните её без аргументов, то получите простой список имеющихся у вас веток:</p>

<pre><code>$ git branch
  iss53
* master
  testing
</code></pre>

<p>Обратите внимание на символ <code>*</code>, стоящий перед веткой <code>master</code>: он указывает на ветку, на которой вы находитесь в настоящий момент. Это означает, что если вы сейчас выполните коммит, ветка <code>master</code> переместится вперёд в соответствии с вашими последними изменениями. Чтобы посмотреть последний коммит на каждой из веток, выполните команду <code>git branch -v</code>:</p>

<pre><code>$ git branch -v
  iss53   93b412c fix javascript issue
* master  7a98805 Merge branch 'iss53'
  testing 782fd34 add scott to the author list in the readmes
</code></pre>

<p>Ещё одна полезная возможность для выяснения состояния веток состоит в том, чтобы оставить в этом списке только те ветки, которые вы слили (или не слили) в ветку, на которой сейчас находитесь. Для этих целей в Git'е есть опции <code>--merged</code> и <code>--no-merged</code>. Чтобы посмотреть те ветки, которые вы уже слили с текущей, можете выполнить команду <code>git branch --merged</code>:</p>

<pre><code>$ git branch --merged
  iss53
* master
</code></pre>

<p>Из-за того что мы ранее слили <code>iss53</code>, мы видим её в этом списке. Те ветки из этого списка, перед которыми нет символа <code>*</code>, можно смело удалять командой <code>git branch -d</code>; вы уже включили наработки из этих веток в другую ветку, так что вы ничего не потеряете.</p>

<p>Чтобы увидеть все ветки, содержащие наработки, которые вы пока ещё не слили в текущую ветку, выполните команду <code>git branch --no-merged</code>:</p>

<pre><code>$ git branch --no-merged
  testing
</code></pre>

<p>Вы увидите оставшуюся ветку. Так как она содержит ещё не слитые наработки, попытка удалить её командой <code>git branch -d</code> не увенчается успехом:</p>

<pre><code>$ git branch -d testing
error: The branch 'testing' is not an ancestor of your current HEAD.
If you are sure you want to delete it, run 'git branch -D testing'.
</code></pre>

<p>Если вы действительно хотите удалить ветку и потерять наработки, вы можете сделать это при помощи опции <code>-D</code>, как указано в подсказке.</p>

</div>
</div>


<div id="main" class="book edition1">
    <h1>3.4 Ветвление в Git - Приёмы работы с ветками</h1>
  <div><h2>Приёмы работы с ветками</h2>

<p>Теперь, когда вы познакомились с основами ветвления и слияния, что вам делать с ветками дальше? В этом разделе мы рассмотрим некоторые стандартные приёмы работы, которые становятся возможными благодаря лёгкости осуществления ветвления. И вы сможете выбрать, включить ли вам какие-то из них в свой цикл разработки.</p>

<h3 id="Долгоживущие-ветки"><a href="#Долгоживущие-ветки">Долгоживущие ветки</a></h3>

<p>Так как Git использует простое трёхходовое слияние, периодически сливать одну ветку с другой на протяжении большого промежутка времени достаточно просто. Это значит, вы можете иметь несколько веток, которые всегда открыты и которые вы используете для разных стадий вашего цикла разработки; вы можете регулярно сливать их одну в другую.</p>

<p>Многие разработчики Git'а придерживаются такого подхода, при котором ветка <code>master</code> содержит исключительно стабильный код — единственный выпускаемый код. Для разработки и тестирования используется параллельная ветка, называемая <code>develop</code> или <code>next</code>, она может не быть стабильной постоянно, но в стабильные моменты её можно слить в <code>master</code>. Эта ветка используется для объединения завершённых задач из тематических веток (временных веток наподобие <code>iss53</code>), чтобы удостовериться, что эти изменения проходят все тесты и не вызывают ошибок.</p>

<p>В действительности же, мы говорим об указателях, передвигающихся вверх по линии коммитов, которые вы делаете. Стабильные ветки далеко внизу линии вашей истории коммитов, наиболее свежие ветки находятся ближе к верхушке этой линии (см. рис. 3-18).</p>

<p></p><center><img src="/figures/18333fig0318-tn.png"></center><br> 
Рисунок 3-18. Более стабильные ветки, как правило, находятся дальше в истории коммитов.<p></p>

<p>В общем, об этом проще думать как о силосных башнях, где набор коммитов переходит в более стабильную башню только тогда, когда он полностью протестирован (см. рис. 3-19).</p>

<p></p><center><img src="/figures/18333fig0319-tn.png"></center><br> 
Рисунок 3-19. Может быть полезным думать о ветках как о силосных башнях.<p></p>

<p>Вы можете применять эту идею для нескольких разных уровней стабильности. Некоторые большие проекты также имеют ветку <code>proposed</code> или <code>pu</code> (proposed updates — предлагаемые изменения), которые включают в себя ветки, не готовые для перехода в ветку <code>next</code> или <code>master</code>. Идея такова, что ваши ветки находятся на разных уровнях стабильности; когда они достигают более высокого уровня стабильности, они сливаются с веткой, стоящей на более высоком уровне.
Опять-таки, иметь долгоживущие ветки не обязательно, но зачастую это полезно, особенно когда вы имеете дело с очень большими и сложными проектами.</p>

<h3 id="Тематические-ветки"><a href="#Тематические-ветки">Тематические ветки</a></h3>

<p>Тематические ветки, однако, полезны в проектах любого размера. Тематическая ветка — недолговечная ветка, которую вы создаёте и используете для работы над некоторой отдельной функциональностью или для вспомогательной работы. Это то, чего вы, вероятно, никогда не делали с системами контроля версий раньше, так как создание и слияние веток обычно слишком затратно. Но в Git'е принято создавать ветки, работать над ними, сливать и удалять их по несколько раз в день.</p>

<p>Мы видели подобное в последнем разделе, где вы создавали ветки <code>iss53</code> и <code>hotfix</code>. Вы сделали всего несколько коммитов на этих ветках и удалили их сразу же после слияния с основной веткой. Такая техника позволяет быстро и полноценно переключать контекст. Ибо когда все изменения разбиты по веткам и определённым темам, намного проще понять, что было сделано, во время проверки и просмотра кода. Вы можете сохранить там изменения на несколько минут, дней или месяцев, а затем, когда они готовы, слить их в основную ветку, независимо от порядка, в котором их создавали или работали над ними.</p>

<p>Рассмотрим пример, когда при выполнении некоторой работы в ветке <code>master</code>, делается новая ветка для решения некой проблемы (<code>iss91</code>), выполняется немного работы на ней, от неё ответвляется ещё одна ветка для другого пути решения той же задачи (<code>iss91v2</code>), потом осуществляется переход назад на основную ветку (<code>master</code>), и некоторое время работа ведётся на ней, затем делается ответвление от неё для выполнения чего-то, в чём вы не уверены, что это хорошая идея (ветка <code>dumbidea</code>). Ваша история коммитов будет выглядеть примерно так как на рисунке 3-20.</p>

<p></p><center><img src="/figures/18333fig0320-tn.png"></center><br> 
Рисунок 3-20. История коммитов с несколькими тематическими ветками.<p></p>

<p>Теперь представим, вы решили, что вам больше нравится второе решение для вашей задачи (<code>iss91v2</code>); и вы показываете ветку <code>dumbidea</code> вашим коллегам и оказывается, что она просто гениальна. Так что вы можете выбросить оригинальную ветку <code>iss91</code> (теряя при этом коммиты C5 и C6) и слить две другие. Тогда ваша история будет выглядеть как на рисунке 3-21.</p>

<p></p><center><img src="/figures/18333fig0321-tn.png"></center><br> 
Рисунок 3-21. Ваша история после слияния dumbidea и iss91v2.<p></p>

<p>Важно запомнить, что когда вы выполняете все эти действия, ветки являются полностью локальными. Когда вы выполняете ветвление и слияние, всё происходит только в вашем репозитории — связь с сервером не осуществляется.</p>

</div>
</div>


</body>
</html>